Package minijava;

Helpers
  all = [1 .. 127];
  digit = [ '0' .. '9' ];
  idbegin = [['a' .. 'z'] + ['A' .. 'Z']];
  nondigit = ['_' + [['a' .. 'z'] + ['A' .. 'Z']]];
  not_newline = [all - 10];
  not_star = [all - '*'];
  not_star_slash =  [not_star - '/'];

Tokens
  tclass = 'class';
  main = 'static void main';
  extends = 'extends';
  public = 'public';
  return = 'return';
  this = 'this';
  new = 'new';

  string_type = 'String';
  int_type = 'int';
  boolean_type = 'boolean';

  if = 'if';
  else = 'else';
  while = 'while';
  print = 'System.out.println';
  lenght = 'lenght';
  semicolon = ';';
  comma = ',';
  equal = '=';

  true = 'true';
  false = 'false';

  lsquare = '[';
  rsquare = ']';
  lcurly = '{';
  rcurly = '}';
  lparen = '(';
  rparen = ')';
  

  id = nondigit (digit|nondigit)*;
  integer = digit*;
  less = '<';
  and = '&&';
  addsub = ('+' | '-');
  mul = '*';
  dot = '.';
  not = '!';

  comment = '//' not_newline* 10 |
            '/*' not_star* '*'+ (not_star_slash not_star* '*'+)* '/';
  blank = (' ' | 13 | 9 | 10)+;

Ignored Tokens
  blank,
  comment;


Productions
  program = 
    mainclass classdecl*;
  
  mainclass = 
    tclass [classid]:id [classlcurly]:lcurly public main lparen string_type lsquare rsquare [argid]:id rparen [mainlcurly]:lcurly statement [mainrcurly]:rcurly [classrcurly]:rcurly;     
  
  classdecl = 
    {simple_class} tclass id lcurly vardecl* methoddecl* rcurly |
	{extended_class} tclass [classid]:id extends [superid]:id lcurly vardecl* methoddecl* rcurly;
  
  vardecl = 
    type id;
  
  methoddecl = 
    public type id lparen formallist rparen lcurly vardecl* statement* return exp semicolon rcurly;
  
  formallist = 
    flist?;
  
  flist = 
    type id formalrest*;
  
  formalrest = 
    comma type id;

  type =
    {int_array_type} int_type lsquare rsquare |
	{boolean_type} boolean_type |
	{int_type} int_type |
	{id_type} id;

  statement =
    {statements} lcurly statement* rcurly |
	{if} lparen exp rparen [ifstm]:statement else [elsestm]:statement |
    {print} print lparen exp rparen semicolon |
    {id_attribution} id equal exp semicolon |
    {array_attribution} id lsquare [indexexp]:exp rsquare equal [rightexp]:exp semicolon;

  /*********************************************
  ordem de precedencia das expressoes (http://www.uni-bonn.de/~manfear/javaoperators.php):
  &&
  <
  + -
  *
  !
  .
  ()
  []
  **********************************************/
  exp =
    less_exp and_sentence*;

  and_sentence =
    and exp;

  less_exp =
    addsub_exp less_sentence*;

  less_sentence = 
    less less_exp;

  addsub_exp =
    mul_exp addsub_exp*;

  addsub_sentence =
    addsub addsub_exp;

  mul_exp =
    dot_exp mul_sentence*;

  mul_sentence =
    mul mul_exp;

  dot_exp =
    array_exp dot_sentence?;

  dot_sentence =
    {lenght} dot lenght |
	{method} dot id lparen explist rparen;
   
  array_exp =
    final_exp array_sentence?;

  array_sentence =
    lsquare exp rsquare;

  final_exp =
	{integer_literal} integer |
	{true} true |
	{false} false |
	{id} id |
	{this} this |
	{new_int_array} new int_type lsquare exp rsquare |
	{new_id} new id lparen rparen |
	{not_expr} not exp |
	{paren_expr} lparen exp rparen;

  explist =
    elist?;

  elist =
    exp exprest*;
    
  exprest =
    comma exp; 
    
