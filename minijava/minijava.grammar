Package minijava;

Helpers
  all = [1 .. 127];
  digit = [ '0' .. '9' ];
  idbegin = [['a' .. 'z'] + ['A' .. 'Z']];
  nondigit = ['_' + [['a' .. 'z'] + ['A' .. 'Z']]];
  not_newline = [all - 10];
  not_star = [all - '*'];
  not_star_slash =  [not_star - '/'];

Tokens
  tclass = 'class';
  main = 'static void main';
  extends = 'extends';
  public = 'public';
  return = 'return';
  this = 'this';
  new = 'new';

  string_type = 'String';
  int_type = 'int';
  boolean_type = 'boolean';

  if = 'if';
  else = 'else';
  while = 'while';
  print = 'System.out.println';
  lenght = 'lenght';
  semicolon = ';';
  comma = ',';
  equal = '=';

  true = 'true';
  false = 'false';

  lsquare = '[';
  rsquare = ']';
  lcurly = '{';
  rcurly = '}';
  lparen = '(';
  rparen = ')';
  

  id = nondigit (digit|nondigit)*;
  integer = digit*;
  less = '<';
  and = '&&';
  addsub = ('+' | '-');
  mul = '*';
  dot = '.';
  not = '!';

  comment = '//' not_newline* 10 |
            '/*' not_star* '*'+ (not_star_slash not_star* '*'+)* '/';
  blank = (' ' | 13 | 9 | 10)+;

Ignored Tokens
  blank,
  comment;


Productions
  program = 
    mainclass classdecl*;
  
  mainclass {-> mainclass} = 
    tclass [classid]:id [classlcurly]:lcurly public main lparen string_type lsquare rsquare [argid]:id rparen [mainlcurly]:lcurly statement [mainrcurly]:rcurly [classrcurly]:rcurly
      {-> New mainclass(classid, argid)};
  
  classdecl {-> classdecl} = 
    {simple_class} tclass [classid]:id lcurly [vars]:vardecl* [methods]:methoddecl* rcurly 
      {-> New classdecl(classid, Null, [vars.vardecl], [methods.methoddecl])} |
    {extended_class} tclass [classid]:id extends [superid]:id lcurly [vars]:vardecl* [methods]:methoddecl* rcurly;
      {-> New classdecl(classid, superid, [vars.vardecl], [methods.methoddecl])}

  vardecl {-> vardecl} = 
    [vartype]:type [varid]:id
      {-> New vardecl([vartype.type], varid)};
  
  methoddecl {-> methoddecl} = 
    public [returntype]:type [methodid]:id lparen [formals]:formallist rparen lcurly [locals]:vardecl* [body]:statement* return [returnexp]:exp semicolon rcurly
      {-> New methoddecl([returntype.type], methodid, [formals.formallist], [locals.vardecl], [body.statement], [returnexp.exp])};
  
  formallist {-> formallist} =
    {notempty_formallist} [formaltype]:type [formalid]:id [formaltail]:formaltail*
      {-> New formallist([formaltype.type], formalid, [tail.formaltail])} |
    {empty_formallist}
      {-> New formallist(null)};
  
  formaltail {-> formaltail} =
    comma [formaltype]:type [formalid]:id
      {-> New formaltail([formaltype.type], formalid)};

  type {-> type} =
    {int_array_type} [int_array]:int_type lsquare rsquare {-> New type(int_array)} |
    {boolean_type} [boolean]:boolean_type {-> New type(boolean)} |
    {int_type} [int]:int_type {-> New type(int)} |
    {id_type} [id]:id {-> New type(id)};

  statement {-> statement} =
    [stmlist]:stmlist {-> New statement(stmlist)} |
    [ifstm]:ifstm {-> New statement(ifstm)} |
    [printstm]:printstm {-> New statement(printstm)} |
    [assignstm]:assignstm {-> New statement(assignstm)};

  /**
   * Statements
   */
  stmlist {-> stmlist} =
    lcurly [statements]:statement* rcurly 
      {-> New stmlist([statements.statement])};

  ifstm {-> ifstm} =
    if lparen [condition]:exp rparen [ifstm]:statement else [elsestm]:statement 
      {-> New ifstm([condition.exp], [ifstm.statement], [elsestm.statement])};

  printstm {-> printstm} =
    print lparen [exp]:exp rparen semicolon
      {-> New printstm([exp.exp])}

  assignstm {-> assignstm} =
    {id_assignstm} [id]:id equal [rightexp]:exp semicolon 
      {-> New assignstm(id, null, [rightexp.exp])} |
    {array_assignstm} [id]:id lsquare [indexexp]:exp rsquare equal [rightexp]:exp semicolon
      {-> New assignstm(id, [indexexp.exp], [rightexp.exp])};

  /**
   * Expressions
   * See precedence list at
   * @link http://www.cs.uwf.edu/~eelsheik/cop2253/resources/op_precedence.html
   *  && , <, +, -, *, !, ., [], ()
   */
  exp =
    less_exp and_sentence*;

  and_sentence =
    and less_exp;

  less_exp =
    addsub_exp less_sentence*;

  less_sentence = 
    less addsub_exp;

  addsub_exp =
    mul_exp addsub_sentence*;

  addsub_sentence =
    addsub mul_exp;

  mul_exp =
    not_exp mul_sentence*;

  mul_sentence =
    mul not_exp;

  not_exp = 
    {not_exp} not not_exp |
    {dot_exp} dot_exp;

  dot_exp =
    array_exp dot_sentence?;

  dot_sentence =
    {lenght} dot lenght |
    {method} dot id lparen explist rparen;
   
  array_exp =
    final_exp array_sentence?;

  array_sentence =
    lsquare exp rsquare;

  final_exp =
    {integer_literal} integer |
    {true} true |
    {false} false |
    {id} id |
    {this} this |
    {new_int_array} new int_type lsquare exp rsquare |
    {new_id} new id lparen rparen |
    {paren_expr} lparen exp rparen;

  explist =
    {explist} exp exprest* |
    {blank_explist} ;
    
  exprest =
    comma exp; 
    
Abstract Syntax Tree
  mainclass =
    [classid]:id [argid]:id;

  classdecl =
    [classname]:id [super]:id? [vars]:vardecl* [methods]:methoddecl*;

  vardecl =
    [vartype]:type [varid]:id;

  methoddecl =
    [returntype]:type [methodid]:id [formals]:formallist [locals]:vardecl* [body]:statement* [returnexp]:exp;

  type =
    [int_array]:int_type |
    [boolean]:boolean_type |
    [int]:int_type |
    [id]:id;

  formallist =
    ([formaltype]:type [formalid]:id [formaltail]:formaltail*)?;

  formaltail =
    [formaltype]:type [formalid]:id;

  statement = 
    [stmlist]:stmlist |
    [ifstm]:ifstm |
    [printstm]:printstm |
    [id_assignstm]:id_assignstm |
    [array_assignstm]:array_assignstm;

  stmlist =
    [statements]:statement*;

  ifstm =
    [condition]:exp [ifstm]:statement [elsestm]:statement;

  printstm =
    [exp]:exp;

  assignstm =
    [id]:id [indexexp]:exp? [rightexp]:exp;

