Package minijava;

Helpers
  all = [1 .. 127];
  digit = [ '0' .. '9' ];
  idbegin = [['a' .. 'z'] + ['A' .. 'Z']];
  nondigit = ['_' + [['a' .. 'z'] + ['A' .. 'Z']]];
  not_newline = [all - 10];
  not_star = [all - '*'];
  not_star_slash =  [not_star - '/'];

Tokens
  tclass = 'class';
  main = 'static void main';
  extends = 'extends';
  public = 'public';
  return = 'return';
  this = 'this';
  new = 'new';

  string_type = 'String';
  int_type = 'int';
  boolean_type = 'boolean';

  if = 'if';
  else = 'else';
  while = 'while';
  print = 'System.out.println';
  lenght = 'lenght';
  semicolon = ';';
  comma = ',';
  equal = '=';

  true = 'true';
  false = 'false';

  lsquare = '[';
  rsquare = ']';
  lcurly = '{';
  rcurly = '}';
  lparen = '(';
  rparen = ')';
  

  id = nondigit (digit|nondigit)*;
  integer = digit+;
  less = '<';
  and = '&&';
  plus = '+';
  minus = '-';
  mul = '*';
  dot = '.';
  not = '!';

  comment = '//' not_newline* 10 |
            '/*' not_star* '*'+ (not_star_slash not_star* '*'+)* '/';
  blank = (' ' | 13 | 9 | 10)+;

Ignored Tokens
  blank,
  comment;


Productions

  program  = 
    mainclass classdecl*;
  
  mainclass  = 
    tclass [classid]:id 
	  [classlcurly]:lcurly 
	    public main lparen string_type lsquare rsquare [argid]:id rparen
	      [mainlcurly]:lcurly 
	        statement 
	      [mainrcurly]:rcurly 
      [classrcurly]:rcurly;
  
  classdecl  = 
    {simple_class} 
	tclass [classid]:id 
	  lcurly
        [vars]:vardecl* 
	    [methods]:methoddecl* 
      rcurly 
       |
    {extended_class} 
    tclass [classid]:id extends [superid]:id 
      lcurly
        [vars]:vardecl* [methods]:methoddecl* 
      rcurly;


  vardecl  = 
    [vartype]:type [varid]:id semicolon;
  
  methoddecl  = 
    public [returntype]:type [methodid]:id lparen [formals]:formallist rparen 
      lcurly 
        [locals]:vardecl* 
        [body]:statement* 
        return [returnexp]:exp semicolon 
      rcurly;
  
  formallist  =
    {notempty_formallist} formal formaltail*
       |
    {empty_formallist} ;
 
  formal  =
    type id ;

  formaltail  =
    comma type id;

  type  =
    {int_array_type} [int_array]:int_type lsquare rsquare  |
    {boolean_type} boolean_type  |
    {int_type} int_type  |
    {id_type} id;

  statement  =
    {block} lcurly [statements]:statement* rcurly 
         |
    {if} if lparen [condition]:exp rparen [ifstm]:statement else [elsestm]:statement 
         |
    {while} while lparen exp rparen statement
         |
    {print} print lparen exp rparen semicolon
         |
    {assign} id equal [rightexp]:exp semicolon 
         |
    {arrayassign} [id]:id lsquare [indexexp]:exp rsquare equal [rightexp]:exp semicolon;

  /**
   * Expressions
   * See precedence list at
   * @link http://www.cs.uwf.edu/~eelsheik/cop2253/resources/op_precedence.html
   *  &&  <  +  -  *  !  .  []  ()
   */
  exp  =
    {and} exp and less_exp 
       |
    {less_exp} less_exp;

  less_exp  =
    {less} less_exp less addsub_exp
       |
    {addsub_exp} addsub_exp;

  addsub_exp  =
    {plus} addsub_exp plus mul_exp
       |
    {minus} addsub_exp minus mul_exp
       |
    {mul_exp} mul_exp;

  mul_exp  =
    {times} mul_exp mul not_exp 
      |
    {not_exp} ;

  not_exp  = 
    {not_exp} not not_exp
       |
    {dot_exp} dot_exp
      ;

  //ta certo isso aqui? to em duvida..
  dot_exp  =
    {lenght} dot_exp dot lenght 
       |
    {call} dot_exp dot id lparen explist rparen 
       |
    {array_exp} array_exp
      ; 
  
  array_exp  =
    {array} final_exp lsquare exp rsquare //exp ou addsub_exp?
      |
    {final_exp} final_exp
      ;

  final_exp =
    {integer_literal} integer 
       |
    {true} true 
       |
    {false} false
       |
    {id} id
       |
    {this} this
       |
    {new_int_array} new int_type lsquare exp rsquare
       |
    {new_id} new id lparen rparen
       |
    {paren_expr} lparen exp rparen
      ;

  explist =
    {explist} exp exprest* 
       |
    {blank_explist} 
      ;
    
  exprest  =
    comma exp
      ; 
