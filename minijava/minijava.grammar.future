Package minijava;

Helpers
  all = [1 .. 127];
  digit = [ '0' .. '9' ];
  idbegin = [['a' .. 'z'] + ['A' .. 'Z']];
  nondigit = ['_' + [['a' .. 'z'] + ['A' .. 'Z']]];
  not_newline = [all - 10];
  not_star = [all - '*'];
  not_star_slash =  [not_star - '/'];

Tokens
  class = 'class';
  main = 'static void main';
  extends = 'extends';
  public = 'public';
  return = 'return';
  this = 'this';
  new = 'new';

  string_type = 'String';
  int_type = 'int';
  boolean_type = 'boolean';

  if = 'if';
  else = 'else';
  while = 'while';
  print = 'System.out.println';
  lenght = 'lenght';
  semicolon = ';';
  comma = ',';
  dot = '.';
  not = '!';
  equal = '=';

  true = 'true';
  false = 'false';

  lsquare = '[';
  rsquare = ']';
  lcurly = '{';
  rcurly = '}';
  lparen = '(';
  rparen = ')';
  

  id = nondigit (digit|nondigit)*;
  integer = digit*;
  op = ('&&' | '<' | '+' | '-' | '*'); /* nao tem !=, >, / ? */

  comment = '//' not_newline* 10 |
            '/*' not_star* '*'+ (not_star_slash not_star* '*'+)* '/';
  blank = (' ' | 13 | 9 | 10)+;

Ignored Tokens
 blank,
 comment;


Productions
  Program = 
    MainClass ClassDecl*;
  
  MainClass = 
    class id lcurly public main lparen string_type lsquare rsquare id rparen lcurly Statement rcurly rcurly;     
  
  ClassDecl = 
    {simple_class} class id lcurly VarDecl* MethodDecl* rcurly |
	{extended_class} class id extends id lcurly VarDecl* MethodDecl* rcurly;
  
  VarDecl = 
    Type id;
  
  MethodDecl = 
    public Type id lparen FormalList rparen lcurly VarDecl* Statement* return Exp semicolon rcurly;
  
  FormalList = 
    FList?;
  
  FList = 
    Type id FormalRest*;
  
  FormalRest = 
    comma Type id

  Type =
    {int_array_type} int_type lsquare rsquare |
	{boolean_type} boolean_type |
	{int_type} int_type |
	{id_type} id

  Statement =
    {Statements} lcurly Statement* rcurly |
	{if} lparen Exp rparen Statement else Statement |
    {print} print lparen Exp rparen semicolon |
    {id_attribution} id equal Exp semicolon |
    {array_attribution} id lsquare Exp rsquare equal Exp semicolon;

  Exp =
    {operation} Exp op Exp |
	{array} Exp lsquare Exp rsquare |
	{lenght} Exp dot lenght |
	{method} Exp dot id lparen ExpList rparen |
	{integer_literal} integer |
	{true} true |
	{false} false |
	{id} id |
	{this} this |
	{new_int_array} new int_type lsquare Exp rsquare |
	{new_id} new id lparen rparen |
	{not_expr} not Exp |
	{paren_expr} lparen Exp rparen;
	
  ExpList =
    EList?;

  EList {ExpList} =
    Exp ExpRest*;
    
  ExpRest {ExpRest} =
    comma Exp; 
    
